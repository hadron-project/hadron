<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hadron | event streaming, workflow orchestration &amp; messaging</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Hadron user guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Hadron</a></li><li class="chapter-item expanded affix "><li class="part-title">Overview</li><li class="chapter-item expanded "><a href="overview/kubernetes.html"><strong aria-hidden="true">2.</strong> Kubernetes</a></li><li class="chapter-item expanded "><a href="overview/cloud-events.html"><strong aria-hidden="true">3.</strong> CloudEvents</a></li><li class="chapter-item expanded "><a href="overview/streams.html"><strong aria-hidden="true">4.</strong> Streams</a></li><li class="chapter-item expanded "><a href="overview/pipelines.html"><strong aria-hidden="true">5.</strong> Pipelines</a></li><li class="chapter-item expanded "><a href="overview/ephemeral-messaging.html"><strong aria-hidden="true">6.</strong> Ephemeral Messaging</a></li><li class="chapter-item expanded "><a href="overview/rpc.html"><strong aria-hidden="true">7.</strong> RPC</a></li><li class="chapter-item expanded affix "><li class="part-title">Clients</li><li class="chapter-item expanded affix "><li class="part-title">CLI</li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/schema.html"><strong aria-hidden="true">8.</strong> Schema Management</a></li><li class="chapter-item expanded "><a href="reference/users-tokens.html"><strong aria-hidden="true">9.</strong> Users &amp; Tokens</a></li><li class="chapter-item expanded "><a href="reference/namespaces.html"><strong aria-hidden="true">10.</strong> Namespaces</a></li><li class="chapter-item expanded "><a href="reference/streams.html"><strong aria-hidden="true">11.</strong> Streams</a></li><li class="chapter-item expanded "><a href="reference/pipelines.html"><strong aria-hidden="true">12.</strong> Pipelines</a></li><li class="chapter-item expanded "><a href="reference/ephemeral-messaging.html"><strong aria-hidden="true">13.</strong> Ephemeral Messaging</a></li><li class="chapter-item expanded "><a href="reference/rpc.html"><strong aria-hidden="true">14.</strong> RPC</a></li><li class="chapter-item expanded "><a href="reference/config-management.html"><strong aria-hidden="true">15.</strong> Config Management</a></li><li class="chapter-item expanded "><a href="reference/cli.html"><strong aria-hidden="true">16.</strong> Hadron CLI</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Hadron | event streaming, workflow orchestration &amp; messaging</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#hadron" id="hadron">Hadron</a></h1>
<p>Hadron is the Kubernetes native and CloudEvents native distributed event streaming, event orchestration &amp; messaging platform.</p>
<p>Hadron is built around three core primitives: durable streams, ephemeral messaging &amp; RPC messaging. Durable streams offer configurable durability, and robust consumer patterns. Ephemeral messaging offers topic based publish/subscribe patterns with wildcards, fanout, load balancing queue groups, and more. RPC messaging offers request/response patterns for service-oriented architectures.</p>
<p>Hadron builds upon these core primitives to offer piplines. Pipelines are pre-defined multi-stage data workflows, structured as a graph. Pipelines provide transactional guarantees over ack'ing a stage's work and the delivery of the next stage's data. With Pipelines, Hadron provides a platform with better features, and greater guarantees for building distributed architectures.</p>
<p>Older AMQP style systems were great, but fall short of Kafka-like streaming capabilities, specifically message persistence. Kafka-like systems lack ephemeral &amp; RPC messaging. More recent blends of the technologies, offer a nice combination, but lack many of the core features needed from both domains. Hadron offers the best of all of these paradigms, adds Pipelines for more powerful architectures, and is shipped as a single binary, written in Rust, with blazing speed, safety, and reliability.</p>
<p>Hadron also features a very simple wire protocol based on protocol buffers for client-server communication. Hadron also ships with a powerful Rust client library for native use in Rust, or for use in any other language supporting C FFI. Language specific wrappers are (will be) maintained in various languages built around the core Rust implementation.</p>
<h3><a class="header" href="#learn" id="learn">Learn</a></h3>
<p>Head over to the <a href="https://hadron-project.github.io/hadron/">Hadron Guide</a> to learn more.</p>
<h3><a class="header" href="#license" id="license">LICENSE</a></h3>
<p>Unless otherwise noted, the Hadron source files are distributed under the Apache Version 2.0 license found in the LICENSE file.</p>
<h1><a class="header" href="#hadron--kubernetes" id="hadron--kubernetes">Hadron &amp; Kubernetes</a></h1>
<blockquote>
<p>Kubernetes, also known as K8s, is an open-source system for automating deployment, scaling, and management of containerized applications.
<br/><small><i>~ <a href="https://kubernetes.io/">kubernetes.io</a></i></small></p>
</blockquote>
<p>Kubernetes has become a cornerstone of the modern cloud ecosystem, and Hadron is purpose built for the Kubernetes platform. Hadron is native to Kubernetes. It was born here and it knows the ins and outs.</p>
<p>Hadron is designed from the ground up to take full advantage of Kubernetes and its rich API for deploying and running applications. Building upon this foundation has enabled Hadron to achieve an operational model with a simple setup, which removes performance bottlenecks, simplifies clustering and consensus, provides predictable and clear scalability, and positions Hadron for seamless and intuitive integration with user applications and infrastructure.</p>
<p>Each of the above points merits deeper discussion, all of which are covered in further detail throughout the reference section of this guide. Here are the highlights.</p>
<h3><a class="header" href="#simple-setup" id="simple-setup">Simple Setup</a></h3>
<p>Most usage of Hadron will start with the Hadron Helm chart. The chart installs the Hadron Operator along with various other resource. Everything related to Hadron operations is handled by the Operator and is driven via Kubernetes configuration files. Provisioning, auto-scaling, networking, access control, all of this is controlled through a few lines of YAML which can be versioned in source control and reviewed as code.</p>
<p>The entire lifecycle of Hadron clusters is handled by the Operator. Upgrading a cluster to a new version of Hadron, horizontally scaling a cluster, adding credentials and access control, all of this and more is declarative and fully managed, which means no operational headaches for users.</p>
<h3><a class="header" href="#removing-performance-bottlenecks" id="removing-performance-bottlenecks">Removing Performance Bottlenecks</a></h3>
<p>Kubernetes offers deployment models which allow Hadron to completely remove the need for its own distributed consensus algorithms in many cases, especially in the write path of publishing data to streams. Without this overhead, Hadron is able to optimize write throughput, replication, and other performance criteria in ways which would not otherwise be feasible.</p>
<p>These wins come with no downsides. Horizontally scaling a cluster is still fully dynamic, clients are still able to detect cluster topology changes in real-time as they take place, but most importantly: the path which data takes from the moment of publication to the moment it is persisted to disk is direct and simple. No extra network hops. No overhead. Just an HTTP2 data stream directly from the client to the Hadron internal function which writes data to disk. All with absolute ordering per partition.</p>
<h3><a class="header" href="#clustering-and-consensus" id="clustering-and-consensus">Clustering and Consensus</a></h3>
<p>Hadron clusters are dynamic, but never contend over leadership. Even as cluster topology changes, there is never any overhead on consensus. Without this overhead, Hadron is able to achieve an excellent performance profile.</p>
<h3><a class="header" href="#seamless-and-intuitive-integration" id="seamless-and-intuitive-integration">Seamless and Intuitive Integration</a></h3>
<p>Hadron clusters are exposed for application and infrastructure integration using canonical Kubernetes patterns for networking and access. Clients receive a stream of cluster metadata and can react in real-time to topology changes to maximize use of horizontal scaling and high-availability.</p>
<p>If your applications are already running in Kubernetes, then integration couldn't be more simple.</p>
<h1><a class="header" href="#cloudevents" id="cloudevents">CloudEvents</a></h1>
<blockquote>
<p>A specification for describing event data in a common way
<br/><small><i>~ <a href="https://cloudevents.io/">cloudevents.io</a></i></small></p>
</blockquote>
<p>Events are everywhere. Everything is an event. As humans have continued to work with event-driven data streams, we've accumulated many best practices on how to model our data in a reliable, extensible, and intuitive way. CloudEvents is at the heart of this movement, and also happens to be at the very core of Hadron.</p>
<p>Everything in Hadron is an event, a CloudEvents 1.0 event. Streams, Pipelines and all of their inputs and outputs for workflow orchestration, ephemeral messages, everything in Hadron is built around the CloudEvents model.</p>
<h3><a class="header" href="#clear" id="clear">Clear</a></h3>
<p>Hadron events are clear, easy to analyze, and prime for automation and application usage.</p>
<h3><a class="header" href="#interoperable" id="interoperable">Interoperable</a></h3>
<p>Hadron is positioned from the very beginning to integrate seamlessly with the greater event-driven ecosystem.</p>
<h3><a class="header" href="#ready-to-go" id="ready-to-go">Ready to Go</a></h3>
<p>Hadron clients speak CloudEvents fluently. Publishing data to, and consuming data from Hadron is clear, concise, and has broad general purpose application.</p>
<h1><a class="header" href="#streams" id="streams">Streams</a></h1>
<p>These docs are currently under construction.</p>
<h1><a class="header" href="#pipelines" id="pipelines">Pipelines</a></h1>
<p>These docs are currently under construction.</p>
<h1><a class="header" href="#ephemeral-messaging" id="ephemeral-messaging">Ephemeral Messaging</a></h1>
<p>These docs are currently under construction.</p>
<h1><a class="header" href="#rpc" id="rpc">RPC</a></h1>
<p>These docs are currently under construction.</p>
<p>These docs are currently under construction.</p>
<!-- Schema Management
=================
All Hadron resources including Namespaces, Streams, Pipelines, RPC Endpoints, etc, are defined using the Hadron Schema Management system.

The guiding principals of the Hadron Schema Management system are as follows:
- Must be easy to use, convenient, and intuitive.
- Must be natively supported by the hadron CLI, no external tools needed.
- Must be explicit, clear, well-defined.
- Must be idempotent.

The Hadron CLI is used for all aspects of schema management, and schema management files should be committed to one's code repository. Very importantly, Hadron schema management is designed to be idempotent, ensuring that the cluster does not end up in an unexpected state as teams roll changes for their applications.

Hadron uses YAML for its schema language. Simply run `hadron schema init {branchName}` to create a new schema management directory. Here, we will use `service-xyz` as the value for `{branchName}` (more on this later). The Hadron CLI will use the directory `hadron-schema` by default, but this value may be overridden. This will give you a directory structure as follows:

```bash
hadron-schema/
├── .hadron-state.yaml
└── 1608743979-initial.yaml
```

Let's break down each of these files. The leading timestamp, generated at the time of the Hadron CLI invocation, will ensure that files stay sorted, and the Hadron CLI will execute them according to their timestamp order. The `initial` segment in the middle of the timestamped filename is generated by the Hadron CLI as part of generating the new schema management directory. And finally, the `.hadron-state.yaml` file holds state information related to this branch of schema changes, the last applied timestamp, and other info — which is always synchronized with the Hadron cluster. The state file should never be manually edited.

Here are the internals of the `1608743979-initial.yaml` file:

```yaml
# Add your schema changes here. Each schema statement should be delimited by
# a line with the text `---` which indicates the start of a new YAML object.
#
# All of the schema statements in this file will be transactionally applied
# to the system as a whole.
#
# Here is an example `Namespace` declaration:
---
kind: Namespace
name: example
description: This is just an example namespace.

# See the docs at https://docs.hadron.rs/guide/reference/schema.html
```

This is a schema file. In Hadron, schema files declare a set of schema statements to be applied to the Hadron cluster. The Hadron CLI ensures that all schema file names are prefixed with a valid timestamp, which is used to order the statements before attempting to apply them to the cluster.

And the internals of `.hadron-state.yaml`:

```yaml
# NOTE: this file was generated by the Hadron CLI. Do not edit.
branch: service-xyz
```

This is the state management file. This file declares the provided branch name, establishing a link between all schema files in the respective directory. This file is managed by the Hadron CLI itself, and should not be manually modified. As schema files are applied to the cluster, their timestamps are record in this file under the `lastAppliedTimestamp` key. If a schema file's timestamp is earlier than the `lastAppliedTimestamp`, then it will not be applied.

Simply run the following command `hadron schema apply` to apply any outstanding schema files in this directory to the cluster. The Hadron cluster stores the last applied timestamp per branch, and the Hadron CLI refreshes this data before every attempt to apply schema changes.

### New Schema Files
New schema files can be added to the schema management directory with the following command: `hadron schema new {fileName}`. This will create a new schema file in the schema management directory. The Hadron CLI will automatically prefix the new file with the current timestamp.

### Idempotent Workflow & Compaction
The Hadron schema management system is designed to be idempotent based on the simple concepts of branch name and timestamp. This helps to ensure that the cluster does not get into an undesired state due to accidentally applying old changes. This systems has no concept of "rollbacks". We take the fail-forward approach.

Over time, it will be common that a large number of schema files will build up within a schema management directory. Run the `hadron schema compact` command to combine all schema statements into the latest schema file, deleting the old schema files once it is safe to do so.
- Ordering of all schema statements is strictly preserved during compaction of schema files.
- Hadron will only compact schema files which are older than the `lastAppliedTimestamp`.

### Schema Statements
The following is a list of accepted schema statements by `kind`, along with links to their full schema spec.

- [`Namespace`](./namespaces.md#schema)
- [`Stream`](./streams.md#schema)
- [`Pipeline`](./pipelines.md#schema)
- [`Endpoint`](./rpc.md#schema)

### Kubernetes Operator Schema Management
The Hadron Kubernetes Operator ships with the ability to handle all schema management based on CRDs.

This is a work in progress, but here are a few of the design goals:
- `HadronSchemaState` CRDs take the place of the `.hadron-state.yaml` files, declaring a branch name and recording the last applied schema file timestamp. The CRD will need to reference a secret containing a Hadron token which has permissions to make schema changes to the cluster.
- `HadronSchemaFile` CRDs take the place of the standard schema files, and are associated with a parent `HadronSchemaState` CRD by label.
- The operator will order `HadronSchemaFile`s when changes are detected, and then apply the latest changes in order, updating the `HadronSchemaState` CRD, which will probably back its state via ConfigMap. -->
<p>These docs are currently under construction.</p>
<!-- Users & Tokens
==============
Hadron uses a simple but effective permissions model. There are users and there are tokens. Users represent administrators of the Hadron cluster, while tokens represent access grants to specific Hadron resources for use in application code and automation tools.

There are a few different user roles:
- `Owner`: this user has full control over the cluster, all namespaces and all resources.
- `Admin`: admins are the same as owners, except that admin permissions may be revoked by other admins and owners, but admins can not revoked the permissions of an owner.
- `Viewer`: viewers are read-only. They may view any of ther resources of the cluster, but may not modify them.

Users are not allowed to directly use the resources of Hadron, that is what tokens are for. Tokens represent a set of permissions for the bearer of that token. The token ID is retained within Hadron and the token may be deleted, which revokes that token's access to the cluster. Tokens come in a few forms:
- `All`: a permissions grant on all resources in the system.
- `Namespaced`: a set of permissions granted on namespace scoped resources.
- `Metrics`: A permissions grant on only the cluster metrics system.

Namespace grants come in two different forms:
- `Full`: a grant of full permissons on the target namespace.
    - `namespace`: the namespace to which the grant pertains.
- `Limited`: a grant of limited access to specific resources within the target namespace.
    - `namespace`: the namespace to which the grant pertains.
    - `messaging`: an optional `pub/sub/all` enum value indicating access to the namespace's ephemeral messaging exchange.
    - `endpoints`: a list of endpoint permissions with the following structure:
        - `matcher`: the endpoint name matcher to use. May include a wildcard to match endpoint hierarchies. Same wildcard rules apply as described in the [ephemeral messaging chapter](./ephemeral-messaging.md).
        - `access`: a `pub/sub/all` enum value.
    - `streams`: a list of stream permissions with the following structure:
        - `matcher`: the stream name matcher to use. May include a wildcard to match streams hierarchically. Same wildcard rules apply as described in the ephemeral messaging chapter.
        - `access`: a `pub/sub/all` enum value.
    - `schema`: a boolean indicating if the token has permissions to modify the schema of the namespace.

In addition to the above:
- Hadron clusters are initialized with a default `root:root` user bearing the `Owner` role. It is expected that cluster admins will use the root credentials to initialize any other users for the system, and it is expected that the root password will be changed and stored securely or removed in favor of other credentials.
- User & token management is performed via the Hadron CLI. -->
<p>These docs are currently under construction.</p>
<!-- Namespaces
==========
Namespaces are the central unit of resource grouping and access control in Hadron.

## Schema
Namespaces are declared in YAML as part of the [Schema Management system](./schema.md). The schema for the `Namespace` object is as follows:

```yaml
## The kind of object being defined. In this case, a namespace.
kind: Namespace
## The name of the namespace. Each namespace must have a unique name.
name: required string
## A description of this namespace.
description: required string
```

### Details
- Namepsace names must conform to the DNS subdomain naming standards. 1-63 characters, `[-a-zA-Z0-9]`, may not start or end with a hyphen.
- Ephemeral Messaging Exchanges, RPC Endpoints, Streams & Pipelines all exist within namespaces.
- A Namespace always has exactly one Ephemeral Messaging Exchange, and may have any number of RPC Endpoints, Streams and Pipelines.
- Tokens are granted permissions on Namespaces which determine their level of access to those Namespaces and the resources they contain. -->
<p>These docs are currently under construction.</p>
<!-- Streams
=======
Streams are append-only, immutable logs of data.

## Schema
Streams are declared in YAML as part of the [Schema Management system](./schema.md). The schema for the `Stream` object is as follows:

```yaml
## The kind of object being defined. In this case, a stream.
kind: Stream
## The namespace in which this stream is to be created.
namespace: required string
## The name of the stream. Each stream must have a unique name per namespace.
name: required string

## The cluster replica sets which are to be used as partitions for this stream.
partitions: required string

## An optional TTL duration specifying how long records are to be kept on
## the stream.
##
## If not specified, then records will stay on the stream forever.
ttl: optional duration (default none)
```

Streams can be updated the same way all other Hadron DDL objects can be updated. See the [Schema Management chapter](./schema.md) for more details.

### Details
- Stream names may be 1-100 characters long, containing only `[-_.a-zA-Z0-9]`. The `.` can be used to form hierarchies for authorization matching wildcards.
- Streams may have one or more partitions, which may be increased as needed. Horizontally scaling the Hadron cluster and adding more partitions to a stream will allow the write throughput of the stream to horizontally scale.
- Stream data is replicated across each partition's replica set.
- Streams must first be created via the Hadron schema system. See the [Schema Management](./schema.md) chapter for more details.

## Subscriptions
Subscriptions represent a client's interest to consume data from a stream. Subscriptions are created when a client submits a subscription request. Subscription requests must specify the target stream to subscribe to and a name to use for the subscription.

**Consumers & groups:** clients which process records from a stream as part of a subscription are known as consumers. When multiple clients subscribe to the same stream using the same subscription name, this will dynamically form a consumer group and messages will be load-balanced across all members of the group. Consumers will receive all messages without any message level discrimination.

**Durable:** subscriptions are durable in the sense that the group's progress through the stream is stored on disk. Clients may disconnect at any time, and they will be automatically removed from the consumer group, and new consumers may be added to the group just as easily.

**Starting point:** when subscriptions are created, they may specify a starting point: first or latest. The starting point only affects the creation of the consumer group when a subscription is created.

**Subscription Config:** when creating a subscription, there are various configuration options which my be specified in order to control behavior.
- `maxParallelConsumers` (default none): the maximum number of consumers allowed to process messages in parallel. If set to 1, then only one consumer is allowed to process messages at a time for the consumer group.

**Consumer Config:** each individual consumer within a group has its own isolated configuration options.
- `batchSize` (default 100): the maximum number of messages which will be delivered to the consumer per batch.
- `batchWaitMillis` (default 500): the amount of time in milliseconds which the consumer should delay for its batch to fill. This only applies when the consumer's batch has been partially filled.

Subscriptions may be deleted using the `StreamUnsub` client API.

### Ack & Nack
Messages being consumed from a stream must be ack'ed. Once a message is ack'd, it will not be delivered again to the same consumer group.

Messages may be nack'ed, which will cause immediate redelivery by default. A redelivery timeout may be specified, which will cause a timeout to be applied before redelivery of the message to a consumer. Redelivery timeouts are not durable, and are held in-memory by Hadron.

If a client disconnects while it was processing unacknowledged messages, Hadron will redeliver those messages to other live consumers of the same subscription consumer group. -->
<p>These docs are currently under construction.</p>
<!-- Pipelines
=========
Pipelines are multi-stage data workflows, composed of multiple streams, structured as a directed acyclic graph (DAG). Pipelines provide transactional guarantees for multi-stage asynchronous workflows. Pipelines orchestrate the delivery of events to specific pipeline stages, collect outputs from pipeline stages, and enforce stage execution order. Pipelines provide a source of truth for codifying asynchronous event-driven architectures.

## Schema
Pipelines are declared in YAML as part of the [Schema Management system](./schema.md). The schema for the `Pipeline` object is as follows:

```yaml
## The kind of object being defined. In this case, a pipeline.
kind: Pipeline
## The namespace in which this pipeline is to be created.
namespace: required string
## The name of the pipeline. Each pipeline must have a unique name per namespace.
name: required string

## The stream from which this pipeline may be triggered. Only events on this
## stream will trigger this pipeline. The trigger stream must exist in the
## same namespace as the pipeline.
inputStream: required string

## Optional event types of events on the input stream which should trigger new
## instances of this pipeline.
##
## If no triggers are decalred, then all events published to the input stream
## will create new pipeline instances.
triggers:
  - string

## `optional array of <stage>`: An array all stages of which this pipeline is
## composed. Pipelines are composed of one or more stages.
stages:
  ## The name of the stage. Each stage has a unique name per pipeline.
  - name: required string

    ## `optional array of string`: A stage will be executed after all of the
    ## stages in its `after` array have successfully completed.
    ##
    ## Execution order must be acyclic. If this value is empty or omitted,
    ## then this stage is considered to be an initial stage of the pipeline,
    ## and will be invoked with a copy of the event which triggered
    ## the pipeline.
    after:
      ## The name of another stage in this pipeline.
      - required string

    ## `optional array of string`: Stages may depend upon the output of
    ## earlier stages, which also implies an `after` relationship with the
    ## specified stages.
    ##
    ## If no dependencies are declared, then the stage will be provided with
    ## the root event which triggered the respective pipeline instance. The
    ## root event can be referred to directly as `root_event` along with
    ## other stages.
    dependencies:
      ## The name of a stage from this pipeline, or the special name
      ## `root_event` which refers to the root event of a pipeline instance.
      - required string
```

### Details
- Pipelines can be updated the same way all other Hadron schema objects can be updated. See the [Schema Management](./schema.md) chapter for more details.
- Pipeline names may be 1-100 characters long, containing only `[-_.a-zA-Z0-9]`. The `.` can be used to form hierarchies for authorization matching wildcards.
- Pipelines may be composed of 1 or more stages (nodes of the graph).
- The flow of data through the pipeline — inputs and outputs — are the edges of the graph.
- Pipelines may have more than one initial stage. All initial stages of a pipeline will receive a copy of the event which triggered the pipeline.
- Pipelines are exclusive. They represent a single type of action to be taken over the data moving through the pipeline. All consumers of pipeline stages will be treated as being part of the same consumer group and messages will be load balanced across all consumers.
- Pipelines have unique names.
- Pipelines are directed acyclic graphs, cycles are not allowed.
- Hadron ensures that the output of a stage is delivered to all downstream stages with a connected edge, and that the message is `ack`'ed transactionally along with the delivery of that output. This greatly reduces the overhead of error handling and minimizes the difficulties of modelling idempotent workflows.
- Pipeline stages may execute in parallel when stages are children of the same parent stage in the graph, or in serial order when stages are ordered one after another in the graph. The `dependencies` & `after` keywords control this behavior.

## Consumers
Pipeline stages must each be individually subscribed to useing the pipelines subscription API. The pipelines subscription API is uniform for all stages, and allows consumers to think purely in terms of reciving inputs and producing outputs. Hadron consumers are channel based, and multiple channels may exist per network connection to the Hadron cluster. -->
<p>These docs are currently under construction.</p>
<!-- Ephemeral Messaging
===================
A topic-based, at most once delivery messaging system, perfect for ephemeral data.

- Provides **at most once delivery semantics.**
- Messages are published with "topics", similar to AMQP-style topics. Defaults to an empty string. No ack or nack is used for ephemeral messages.
- Consumers may specify a "topic" matcher, which expresses interest in matching messages. Wildcard topic matchers are supported, similar to AMQP-style wildcards.
- If no consumer matches the topic of the message, it will be dropped.
- Consumers may form groups, where messages will be load balanced across healthy group members.
- Consumer group information is synchronously replicated to all nodes when the consumer group is formed and as members join and leave the group, but this information is only held in memory.
- Consumer group load balancing decisions are made by the node which received the message needing to be load balanced.
- Messages will be delivered once to each consumer group matching the message's topic.
- Ephemeral messaging exchanges are implicity created as part of a namespace. Namespaces have one and only one ephemeral messaging exchange.

### Topics
Hadron enforces that message topics adhere to the following pattern `[-_A-Za-z0-9.]*`. In English, this could be read as "all alpha-numeric characters, hyphen, underscore and period". Topics are case-sensitive and can not contain whitespace.

##### Topic Hierarchies
The `.` character is used to create a subject hierarchy. A volcanology team might define the following hierarchy for collecting sensor readings on volcanoes they are monitoring, where volcanoes are grouped by the region they are in, followed by the name of the volcano, then followed by the cardinal point where the sensor is stationed with respect to the center of the volcano.

```
volcanoes.usa
volcanoes.usa.atka
volcanoes.usa.kahoolawe.north
volcanoes.tanzania
volcanoes.tanzania.meru
volcanoes.tanzania.kilimanjaro.east
volcanoes.tanzania.kilimanjaro.west
```

### Wildcard Matchers
There are two wildcard tokens available to subscribers for matching message topics. Subscribers can use these wildcards to listen to multiple topics with a single subscription but Publishers will always use a fully specified subject, without any wildcards (as the wildcard characters are not valid topic characters while publishing).

##### Single-Token Matching
The first wildcard is `*` which will match a single hierarchy token. If the volcanology team needs to build a consumer for monitoring everything from `Kilimanjaro`, it could subscribe to `volcanoes.tanzania.kilimanjaro.*`, which would match `volcanoes.tanzania.kilimanjaro.east` and `volcanoes.tanzania.kilimanjaro.west`.

##### Multi-Token matching
The second wildcard is `>` which will match one or more hierachy tokens, and can only appear at the end of the topic. For example, `volcanoes.usa.>` will match `volcanoes.usa.atka` and `volcanoes.usa.kahoolawe.north`, while `volcanoes.usa.*` would only match `volcanoes.usa.atka` since it can’t match more than one hierarchy token.

### Consumers
Ephemeral message consumers specify a topic matcher and may optionally specify a queue group to begin consuming messages. Every consumer which is part of the same queue group will have messages load balanced across the group. -->
<p>These docs are currently under construction.</p>
<!-- RPC Endpoints
=============
RPC Endpoints provide a service-oriented request/response system, akin to traditional REST APIs or other RPC systems like gRPC.

## Schema
RPC Endpoints are declared in YAML as part of the [Schema Management system](./schema.md). The schema for the `Endpoint` object is as follows:

```yaml
## The kind of object being defined. In this case, a pipeline.
kind: Endpoint
## The namespace in which this endpoint is to be created.
namespace: required string
## The name of the endpoint. Each endpoint must have a unique name per namespace.
name: required string
## The input RPC mode.
input: enum Single | Stream
## The output RPC mode.
output: enum Single | Stream
```

### Details
- Endpoint names may be 1-100 characters long, containing only `[-_.a-zA-Z0-9]`. The `.` can be used to form hierarchies for authorization matching wildcards. Consumers do not use wildcards for endpoints.
- RPC messages are published to a specific endpoint within a namespace.
- RPC endpoints are declared explicity in code and must be created on the server.
- RPC messages are not durable, but if an endpoint has no live consumers when a message is published, an error response will be immediately returned for better control flow.

## Consumers
RPC Endpoints offer consumer patterns similar to the ephemeral messaging system, except that wildcards are not allowed. -->
<p>These docs are currently under construction.</p>
<!-- Config Management
=================
- Hadron does not use config files.
- Only env vars are used for config. If a file is needed, the `.env` file paradigm may be used.
- Config is idempotent, and many config options will only ever be used/evaluated when a node is coming online for the first time.
- Nodes should only ever need to be restarted for upgrading the version of Hadron or for major config changes. -->
<p>These docs are currently under construction.</p>
<!-- Hadron CLI
==========
Hadron ships with a native CLI, called `hadron`, not to be confused with the `hadrond` server. It is the primary mechanism for performing administrative operations on a Hadron cluster. -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
