syntax = "proto3";
package client;

service Client {
  // Open a new transaction.
  //
  // This gRPC endpoint uses a bi-direction stream. The client sends `TransactionClient` messages and
  // the server sends `TransactionServer` messages. The client will send an initial message to initialize
  // the stream and the server will send an initial message to confirm initialization.
  //
  // The initial response will return a transaction ID. The transaction ID may be included in
  // `EphemeralPub` or `StreamPub` requests. Such requests will be recorded in the transaction, but
  // will not be applied until the transaction commits. Once the transaction commits, all commands
  // registered as part of the transaction will atomically be applied. If an error is encountered,
  // then none of the commands will be applied.
  //
  // Once all work in the transaction has been finished, the client should send a second `TransactionClient`
  // message which will commit the transaction. The server will respond with a second `TransactionServer`
  // indicating if the transaction succeeded for failed.
  //
  // Transactions are scoped to the namespace.
  rpc Transaction(stream TransactionClient) returns (stream TransactionServer);

  // Publish an ephemeral message.
  rpc EphemeralPub(EphemeralPubRequest) returns (EphemeralPubResponse);
  // Subscribe to an ephemeral messaging exchange using a given routing key.
  //
  // This gRPC endpoint uses a uni-direction stream. The client sends an initial `EphemeralSubClient`
  // message to setup the subscription stream, and the server will respond with an initial
  // `EphemeralSubServer` message to confirm initialization.
  //
  // From there, the server will send `EphemeralSubServer` messages containing published ephemeral
  // messages matching this subscription's exchange and routing key.
  rpc EphemeralSub(EphemeralSubClient) returns (stream EphemeralSubServer);

  // Publish an RPC request and await its response.
  rpc RpcPub(RpcPubRequest) returns (RpcPubResponse);
  // Subscribe as an RPC handler.
  //
  // This gRPC endpoint uses a bi-direction stream. The client sends `RpcSubClient` messages and
  // the server sends `RpcSubServer` messages. The client will send an initial message to initialize
  // the stream and the server will send an initial message to confirm initialization.
  //
  // From there, the server will send a `RpcSubServer` message any time an RPC has been published
  // and this client connection has been chosen to handle the RPC. The client is then expected to
  // handle the RPC and respond with a `RpcSubClient` message.
  rpc RpcSub(stream RpcSubClient) returns (stream RpcSubServer);

  // Publish an event to a stream.
  rpc StreamPub(StreamPubRequest) returns (StreamPubResponse);
  // Subscribe as an event handler for a specific stream.
  //
  // This gRPC endpoint uses a bi-direction stream. The client sends `StreamSubClient` messages and
  // the server sends `StreamSubServer` messages. The client will send an initial message to initialize
  // the stream and the server will send an initial message to confirm initialization.
  //
  // From there, the server will send a `StreamSubServer` message any time an event has been published
  // to the corresponding stream and this client connection has been chosen to handle event. The client
  // is then expected to handle the event and respond with a `StreamSubClient` message, which will
  // either acknowledge (`ack`) the event indicating that it was successfully processed, or will
  // negatively acknowledge (`nack`) the event indicating that the event was not processed successfully.
  rpc StreamSub(stream StreamSubClient) returns (stream StreamSubServer);
  // Unsubscribes a stream consumer group, deleting the consumer group's offsets for the associated stream.
  rpc StreamUnsub(StreamUnsubRequest) returns (StreamUnsubResponse);

  // Subscribe as an event handler for a specific pipeline stage.
  //
  // This gRPC endpoint uses a bi-direction stream. The client sends `PipelineStageSubClient` messages and
  // the server sends `PipelineStageSubServer` messages. The client will send an initial message to initialize
  // the stream and the server will send an initial message to confirm initialization.
  //
  // From there, the server will send a `PipelineStageSubServer` message to trigger a specific pipeline
  // stage providing the stage's required input. The client is then expected to handle the input
  // event for the specific stage and respond with a `PipelineStageSubClient` message, which will either
  // acknowledge (`ack`) the stage providing any required outputs for the stage, or will negatively
  // acknowledge (`nack`) the stage indicating that the stage was not processed successfully.
  rpc PipelineStageSub(stream PipelineStageSubClient) returns (stream PipelineStageSubServer);

  // Update the schema of the Hadron cluster.
  //
  // This is the one endpoint used for making updates to a Hadron cluster's schema. The given
  // payload should be an array of YAML documents describing schema updates.
  //
  // TODO: update guide on how schema management is setup, changeset docs, &c.
  rpc UpdateSchema(UpdateSchemaRequest) returns (UpdateSchemaResponse);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

message TransactionClient {}

message TransactionServer {}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

message EphemeralPubRequest {}

message EphemeralPubResponse {}

message EphemeralSubClient {}

message EphemeralSubServer {}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

message RpcPubRequest {}

message RpcPubResponse {}

message RpcSubClient {}

message RpcSubServer {}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

message StreamPubRequest {
  // The namespace of the stream to which this event will be published.
  string namespace = 1;
  // The stream to which this event will be published.
  string stream = 2;
  // The payload of this event.
  bytes payload = 3;
}

message StreamPubResponse {
  // The ID of the newly created event.
  uint64 id = 1;
}

message StreamSubClient {}

message StreamSubServer {}

message StreamUnsubRequest {}

message StreamUnsubResponse {}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

message PipelineStageSubClient {}

message PipelineStageSubServer {}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

message UpdateSchemaRequest {
  // A set of Hadron schema documents to apply to the system.
  string schema = 1;
}

message UpdateSchemaResponse {}
