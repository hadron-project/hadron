syntax = "proto3";
package client;

service Client {
  // Publish an ephemeral message.
  rpc EphemeralPub(EphemeralPubRequest) returns (EphemeralPubResponse);
  // Subscribe to an ephemeral messaging exchange using a given routing key.
  //
  // This gRPC endpoint uses a uni-direction stream. The client sends an initial `EphemeralSubClient`
  // message to setup the subscription stream, and the server will respond with an initial
  // `EphemeralSubServer` message to confirm initialization.
  //
  // From there, the server will send `EphemeralSubServer` messages containing published ephemeral
  // messages matching this subscription's exchange and routing key.
  rpc EphemeralSub(EphemeralSubClient) returns (stream EphemeralSubServer);

  // Publish an RPC request and await its response.
  rpc RpcPub(RpcPubRequest) returns (RpcPubResponse);
  // Subscribe as an RPC handler.
  //
  // This gRPC endpoint uses a bi-direction stream. The client sends `RpcSubClient` messages and
  // the server sends `RpcSubServer` messages. The client will send an initial message to initialize
  // the stream and the server will send an initial message to confirm initialization.
  //
  // From there, the server will send a `RpcSubServer` message any time an RPC has been published
  // and this client connection has been chosen to handle the RPC. The client is then expected to
  // handle the RPC and respond with a `RpcSubClient` message.
  rpc RpcSub(stream RpcSubClient) returns (stream RpcSubServer);

  // Publish an event to a stream.
  rpc StreamPub(StreamPubRequest) returns (StreamPubResponse);
  // Subscribe as an event handler for a specific stream.
  //
  // This gRPC endpoint uses a bi-direction stream. The client sends `StreamSubClient` messages and
  // the server sends `StreamSubServer` messages. The client will send an initial message to initialize
  // the stream and the server will send an initial message to confirm initialization.
  //
  // From there, the server will send a `StreamSubServer` message any time an event has been published
  // to the corresponding stream and this client connection has been chosen to handle event. The client
  // is then expected to handle the event and respond with a `StreamSubClient` message, which will
  // either acknowledge (`ack`) the event indicating that it was successfully processed, or will
  // negatively acknowledge (`nack`) the event indicating that the event was not processed successfully.
  rpc StreamSub(stream StreamSubClient) returns (stream StreamSubServer);
  // Unsubscribes a stream consumer group, deleting the consumer group's offsets for the associated stream.
  rpc StreamUnsub(StreamUnsubRequest) returns (StreamUnsubResponse);

  // Subscribe as an event handler for a specific pipeline stage.
  //
  // This gRPC endpoint uses a bi-direction stream. The client sends `PipelineStageSubClient` messages and
  // the server sends `PipelineStageSubServer` messages. The client will send an initial message to initialize
  // the stream and the server will send an initial message to confirm initialization.
  //
  // From there, the server will send a `PipelineStageSubServer` message to trigger a specific pipeline
  // stage providing the stage's required input. The client is then expected to handle the input
  // event for the specific stage and respond with a `PipelineStageSubClient` message, which will either
  // acknowledge (`ack`) the stage providing any required outputs for the stage, or will negatively
  // acknowledge (`nack`) the stage indicating that the stage was not processed successfully.
  rpc PipelineStageSub(stream PipelineStageSubClient) returns (stream PipelineStageSubServer);

  // Update the schema of the Hadron cluster.
  //
  // This is the one endpoint used for making updates to a Hadron cluster's schema. The given
  // payload should be an array of YAML documents describing schema updates. This process is
  // always idempotent, as all documents are required to have a revision number, and old revisions
  // are ignored.
  rpc UpdateSchema(UpdateSchemaRequest) returns (UpdateSchemaResponse);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

message EphemeralPubRequest {}

message EphemeralPubResponse {}

message EphemeralSubClient {}

message EphemeralSubServer {}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

message RpcPubRequest {}

message RpcPubResponse {}

message RpcSubClient {}

message RpcSubServer {}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

message StreamPubRequest {}

message StreamPubResponse {}

message StreamSubClient {}

message StreamSubServer {}

message StreamUnsubRequest {}

message StreamUnsubResponse {}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

message PipelineStageSubClient {}

message PipelineStageSubServer {}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

message UpdateSchemaRequest {}

message UpdateSchemaResponse {}
